\section{Algorithms}

So  far all  metabolic  processes and  queries  of the  status of  the
simulated  tree can  be implemented  using one  of the  following four
generic   algorithms:    ForEach,   Accumulate,   AccumulateDown   and
PropagateUp.  Each of these algorithms traverse the tree in a slightly
different manner  and take care  that the actual metabolic  process or
query implemented  as a functor  is applied to each  tree compartment.
Thus they eliminate the trouble  of writing repetitive and error prone
explicit loops each  time a metabolic process or  query is implemented
or refined.

To  use  these algorithms  include  the  file  Algorithms.h into  your
program. Sample use  of these algorithms can be  obtained by compiling
and  running lignum in  its stl-lignum  project directory.  The sample
tree used also here as an example consists of one main axis containing
one tree segment, one branch whorl and the terminating bud. The branch
whorl contains two auxilliary buds. Using the notation from our papers
the tree can be written as:

\begin{displaymath}
[TS,[[B],[B]],B]
\end{displaymath}

Also the  functors used in subsequent  sections to clarify  the use of
the  generic algorithms  are the  same as  used in  stl-lignum project
directory.
 
\subsection{void ForEach(Tree<TS>\& tree, const Function\& f)}

ForEach is similar to  STL-library  function  for\_each.  In fact   it
applies  for\_each to  each  list  of  tree  compartments  in a  tree.
for\_each in turn simply applies a user defined functor f to each tree
compartment in a list.

\begin{description}
    \item [Arguments] for the function.
      \begin{description}
        \item [tree] The tree.
        \item [f]  The unary   functor  taking a   pointer to a   tree
      compartment as an argument. The functor  must return the pointer
      to a tree compartment.
     \end{description} 
   \item[Returns] The tree and tree compartments possibly modified by f.
\end{description} 

The implementation of ForEach uses   the notion function  composition.
That is, it defines functions h and g such that given the user defined
function f:

\begin{displaymath}
h = (g \circ f)(x) = g(f(x))
\end{displaymath}

The purpose of the function g is  simply to traverse  the tree.  As an
example consider the  following functor DisplayType2 playing  the role
of the function f:

\begin{verbatim}
template <class TS>
class DisplayType2: public AdaptableTCFunction<TS>{
public:
   TreeCompartment<TS>* operator ()(TreeCompartment<TS>* ts)const;
};
\end{verbatim}

The easiest  way  to ensure proper   argument  and return  type  for a
functor  is to inherit from  AdaptableTCFunction<TS>.   It is an empty
class   but predefines   right    argument  and return   types.    The
implementation of  the overloaded function  operator simply prints out
the type of a tree compartment.

\begin{verbatim}
template <class TS> TreeCompartment<TS>* 
DisplayType2<TS>::operator()(TreeCompartment<TS>* tc)const
{
  if (Axis<TS>* myaxis =  dynamic_cast<Axis<TS>*>(tc)){
    cout << "Hello, I'm Axis" << endl;
  }
  //checking other tree compartments similarly
  else if ...  
  ....
  return tc;
}
\end{verbatim}

The call to ForEach to print out the type of each tree compartment is
simply 

\begin{verbatim}
ForEach(tree,DisplayType2<MyTreeSegment>());
\end{verbatim}

ForEach algorithm  can be used  to implement e.g.,  photosynthesis and
respiration.

\section{T& Accumulate(Tree<TS>\& tree, T\& init, const BinOp\& op)}

The algorithm Accumulate can be used to collect data or query a status
of a tree. It  is  similar to STL-library  function  accumulate.  Note
however,  that  in  Accumulate  the  initial  value (also  called  the
identitity element) is passed and returned  as reference, not by value
as in accumulate.  The  reason for this design  decision is that it is
not always numerical data a modeller may want collect.

Accumulate traverses  the tree  and  applies the user  defined  binary
operator op to each  tree compartment with the  initial value that can
be modified according to the binary operator.

\begin{description}
   \item [Arguments] for the function.
     \begin{description}
        \item [tree] The tree.
        \item [init] The initial value. Also called the identity
     element.
        \item [op] The binary operator. The functor must take two
     arguments: the initial value and the pointer to a tree compartment. The
     operator must return the modified initial value.
     \end{description} 
   \item[Returns] The  modified initial value.
\end{description} 

More formally, the implementation of Accumulate uses the notion of
function composition. It defines functions h and g such that given the
user defined function f:

\begin{displaymath}
h = (g \circ f)(x,y) =  g(f(x,y),y)
\end{displaymath}

In practice the x is the  identity and y  is the tree compartment. The
purpose of the function g  is simply to  traverse the tree and it does
not modify the identity element or the tree compartment. As an example
of   the use  of  Accumulate  consider  the  following binary operator
CountCompartments:

\begin{verbatim}
template <class TS>
class CountCompartments{
public:
  int& operator ()(int& id,TreeCompartment<TS>* ts)const;
};
\end{verbatim}

The implementation of the overloaded function operator in
CountCompartments  simply counts the number  of tree compartments in a
tree and echos the type of each compartment.










